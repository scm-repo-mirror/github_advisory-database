{
  "schema_version": "1.4.0",
  "id": "GHSA-h68c-38x6-5x45",
  "modified": "2025-09-17T15:30:38Z",
  "published": "2025-09-17T15:30:38Z",
  "aliases": [
    "CVE-2023-53341"
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:\n\nof/fdt: run soc memory setup when early_init_dt_scan_memory fails\n\nIf memory has been found early_init_dt_scan_memory now returns 1. If\nit hasn't found any memory it will return 0, allowing other memory\nsetup mechanisms to carry on.\n\nPreviously early_init_dt_scan_memory always returned 0 without\ndistinguishing between any kind of memory setup being done or not. Any\ncode path after the early_init_dt_scan memory call in the ramips\nplat_mem_setup code wouldn't be executed anymore. Making\nearly_init_dt_scan_memory the only way to initialize the memory.\n\nSome boards, including my mt7621 based Cudy X6 board, depend on memory\ninitialization being done via the soc_info.mem_detect function\npointer. Those wouldn't be able to obtain memory and panic the kernel\nduring early bootup with the message \"early_init_dt_alloc_memory_arch:\nFailed to allocate 12416 bytes align=0x40\".",
  "severity": [],
  "affected": [],
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53341"
    },
    {
      "type": "WEB",
      "url": "https://git.kernel.org/stable/c/04836fc5b720dfa32ff781383d84f63019abf9b9"
    },
    {
      "type": "WEB",
      "url": "https://git.kernel.org/stable/c/2a12187d5853d9fd5102278cecef7dac7c8ce7ea"
    },
    {
      "type": "WEB",
      "url": "https://git.kernel.org/stable/c/c4849f18185fd4e93b04cd45552f8d68c0240e21"
    }
  ],
  "database_specific": {
    "cwe_ids": [],
    "severity": null,
    "github_reviewed": false,
    "github_reviewed_at": null,
    "nvd_published_at": "2025-09-17T15:15:37Z"
  }
}