{
  "schema_version": "1.4.0",
  "id": "GHSA-mjg7-65xv-hcjw",
  "modified": "2025-10-04T09:30:21Z",
  "published": "2025-10-04T09:30:21Z",
  "aliases": [
    "CVE-2025-39941"
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:\n\nzram: fix slot write race condition\n\nParallel concurrent writes to the same zram index result in leaked\nzsmalloc handles.  Schematically we can have something like this:\n\nCPU0                              CPU1\nzram_slot_lock()\nzs_free(handle)\nzram_slot_lock()\n\t\t\t\tzram_slot_lock()\n\t\t\t\tzs_free(handle)\n\t\t\t\tzram_slot_lock()\n\ncompress\t\t\tcompress\nhandle = zs_malloc()\t\thandle = zs_malloc()\nzram_slot_lock\nzram_set_handle(handle)\nzram_slot_lock\n\t\t\t\tzram_slot_lock\n\t\t\t\tzram_set_handle(handle)\n\t\t\t\tzram_slot_lock\n\nEither CPU0 or CPU1 zsmalloc handle will leak because zs_free() is done\ntoo early.  In fact, we need to reset zram entry right before we set its\nnew handle, all under the same slot lock scope.",
  "severity": [],
  "affected": [],
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39941"
    },
    {
      "type": "WEB",
      "url": "https://git.kernel.org/stable/c/ce4be9e4307c5a60701ff6e0cafa74caffdc54ce"
    },
    {
      "type": "WEB",
      "url": "https://git.kernel.org/stable/c/ff750e9f2c4d63854c33967d1646b5e89a9a19a2"
    }
  ],
  "database_specific": {
    "cwe_ids": [],
    "severity": null,
    "github_reviewed": false,
    "github_reviewed_at": null,
    "nvd_published_at": "2025-10-04T08:15:47Z"
  }
}