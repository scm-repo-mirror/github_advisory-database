{
  "schema_version": "1.4.0",
  "id": "GHSA-345p-7cg4-v4c7",
  "modified": "2026-02-05T00:34:41Z",
  "published": "2026-02-04T20:04:16Z",
  "aliases": [
    "CVE-2026-25536"
  ],
  "summary": "@modelcontextprotocol/sdk has cross-client data leak via shared server/transport instance reuse",
  "details": "### Summary\n\nCross-client response data leak when a single `McpServer`/`Server` and transport instance is reused across multiple client connections, most commonly in stateless `StreamableHTTPServerTransport` deployments.\n\n### Impact\n\n**Who is affected:** Any MCP server deployment using the TypeScript SDK where a single `McpServer` (or `Server`) instance is shared across multiple concurrent client connections. This is most likely in stateless mode (no `sessionIdGenerator`), where the natural but incorrect pattern is to create one server and transport and handle all requests through it. Stateful mode is also affected if the server instance is improperly shared across sessions, though this misconfiguration is less common since the stateful pattern naturally encourages per-session instances.\n\n**What happens:** When two or more MCP clients send requests concurrently through a shared server instance, JSON-RPC message ID collisions cause responses to be routed to the wrong client's HTTP connection. Client A can receive response data intended for Client B, and vice versa, even when authorization was correctly enforced on each individual request.\n\nThe MCP SDK's client generates message IDs using a simple incrementing counter starting at 0. When two clients connect to the same server instance, they produce identical message IDs, causing the transport's internal request-to-stream mapping to overwrite one client's entry with another's â€” routing responses to the wrong HTTP connection.\n\n**Conditions for exploitation:**\n- The server reuses a single `McpServer`/`Server` instance across requests or sessions (rather than creating fresh instances per request/session)\n- Two or more clients connect concurrently\n- Clients generate overlapping JSON-RPC message IDs (virtually guaranteed since the SDK's client uses an incrementing counter starting at 0)\n\n**Not affected:**\n- Stateful servers that create a new `McpServer` + transport per session (the typical and recommended stateful pattern)\n- Stateless servers that create a new `McpServer` + transport per request\n- Single-client environments (e.g., local development with one IDE)\n\n### Patches\n\nThe fix adds runtime guards that turn silent data misrouting into immediate, actionable errors:\n\n1. `Protocol.connect()` now throws if the protocol is already connected to a transport, preventing silent transport overwriting across both stateful and stateless modes\n2. Stateless `StreamableHTTPServerTransport.handleRequest()` now throws if called more than once, enforcing one-request-per-transport in stateless mode\n\nServers that were incorrectly reusing instances will now receive a clear error message directing them to create separate instances per connection.\n\n### Workarounds\n\nIf projects cannot upgrade immediately, ensure the server creates fresh `McpServer` and transport instances for each request (stateless) or session (stateful):\n\n```typescript\n// Stateless mode: create new server + transport per request\napp.post('/mcp', async (req, res) => {\n  const server = new McpServer({ name: 'my-server', version: '1.0.0' });\n  // ... register tools, resources, etc.\n  const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: undefined });\n  await server.connect(transport);\n  await transport.handleRequest(req, res);\n});\n\n// Stateful mode: create new server + transport per session\nconst sessions = new Map();\napp.post('/mcp', async (req, res) => {\n  const sessionId = req.headers['mcp-session-id'];\n  if (sessions.has(sessionId)) {\n    await sessions.get(sessionId).transport.handleRequest(req, res);\n  } else {\n    const server = new McpServer({ name: 'my-server', version: '1.0.0' });\n    // ... register tools, resources, etc.\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () => randomUUID()\n    });\n    await server.connect(transport);\n    sessions.set(transport.sessionId, { server, transport });\n    await transport.handleRequest(req, res);\n  }\n});\n```\n\n### Resources\n\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/204\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/243",
  "severity": [
    {
      "type": "CVSS_V3",
      "score": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N"
    }
  ],
  "affected": [
    {
      "package": {
        "ecosystem": "npm",
        "name": "@modelcontextprotocol/sdk"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "1.10.0"
            },
            {
              "fixed": "1.26.0"
            }
          ]
        }
      ],
      "database_specific": {
        "last_known_affected_version_range": "<= 1.25.3"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/modelcontextprotocol/typescript-sdk/security/advisories/GHSA-345p-7cg4-v4c7"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2026-25536"
    },
    {
      "type": "WEB",
      "url": "https://github.com/modelcontextprotocol/typescript-sdk/issues/204"
    },
    {
      "type": "WEB",
      "url": "https://github.com/modelcontextprotocol/typescript-sdk/issues/243"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/modelcontextprotocol/typescript-sdk"
    }
  ],
  "database_specific": {
    "cwe_ids": [
      "CWE-362"
    ],
    "severity": "HIGH",
    "github_reviewed": true,
    "github_reviewed_at": "2026-02-04T20:04:16Z",
    "nvd_published_at": "2026-02-04T22:15:59Z"
  }
}